/*
 * Copyright 2011-14 Fraunhofer ISE
 *
 * This file is part of OpenMUC.
 * For more information visit http://www.openmuc.org
 *
 * OpenMUC is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * OpenMUC is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with OpenMUC.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package org.openmuc.framework.datalogger.ascii;

import org.openmuc.framework.data.ValueType;
import org.openmuc.framework.datalogger.spi.LogChannel;
import org.openmuc.framework.datalogger.spi.LogRecordContainer;

import java.io.PrintStream;
import java.util.*;

public class LogFileHeader {

    private final double iseFormatVersion = 1.00;
    private final String fileInfo = "generated by AsciiLoger of OpenMUC";

    private String headerOld = null;
    private String headerCurrent = null;

    public LogFileHeader() {

    }

    /**
     * Generate the standard IES Data Format Header and write it into the outputstream 'out'.
     *
     * @param group
     * @param out             output stream
     * @param filename
     * @param loggingInterval
     * @param logChannelList
     */
    public void writeIESDataFormatHeader(LogIntervalContainerGroup group,
                                         PrintStream out,
                                         String filename,
                                         int loggingInterval,
                                         HashMap<String, LogChannel> logChannelList) {
        if (out != null) {

            String timestep_sec = String.valueOf(loggingInterval / (double) 1000);
            if (headerCurrent != null) {
                headerOld = headerCurrent.toString();
            }

            String seperator = IESDataFormatUtils.SEPARATOR;

            StringBuilder sb = new StringBuilder();
            // write general header informations
            sb.append("#ies_format_version: " + iseFormatVersion + "\n");
            sb.append("#file: " + filename + "\n");
            sb.append("#file_info: " + fileInfo + "\n");
            sb.append("#timezone: " + getDiffLocalUTC() + "\n");
            sb.append("#timestep_sec: " + timestep_sec + "\n");
            sb.append(("#"
                       + "col_no"
                       + seperator
                       + "col_name"
                       + seperator
                       + "confidential"
                       + seperator
                       + "measured"
                       + seperator
                       + "unit"
                       + seperator
                       + "category"
                       + seperator
                       + IESDataFormatUtils.COMMENT_NAME
                       + "\n"));
            sb.append(createRow("001",
                                "YYYYMMDD",
                                "FALSE",
                                "FALSE",
                                "0",
                                "time",
                                "INTEGER",
                                8,
                                "Date [human readable]"));
            sb.append(createRow("002",
                                "hhmmss",
                                "FALSE",
                                "FALSE",
                                "0",
                                "time",
                                "SHORT",
                                6,
                                "Time [human readable]"));
            sb.append(createRow("003", "unixtimestamp", "FALSE", "FALSE", "s", "time", "DOUBLE", 14,
                                "lapsed seconds from 01-01-1970"));

            // write channel specific header informations
            int colNumber = 4;
            for (LogRecordContainer container : group.getList()) {
                LogChannel logChannel = logChannelList.get(container.getChannelId());

                String unit = logChannel.getUnit();
                if (unit.equals("")) {
                    unit = "0";
                }
                ValueType vType = logChannel.getValueType();
                String valueType = vType.toString();
                int valueTypeLength = 0;
                if (vType.equals(ValueType.BYTE_ARRAY) || vType.equals(ValueType.STRING)) {
                    valueTypeLength = logChannel.getValueTypeLength();
                }

                String description = logChannel.getDescription();
                if (description.equals("")) {
                    description = "-";
                }

                sb.append(createRow(String.format("%03d", colNumber),
                                    logChannel.getId(),
                                    "FALSE",
                                    "TRUE",
                                    unit,
                                    "other",
                                    valueType,
                                    valueTypeLength,
                                    description));
                colNumber++;
            }

            // write column headers

            sb.append("YYYYMMDD");
            sb.append(IESDataFormatUtils.SEPARATOR);
            sb.append("hhmmss");
            sb.append(IESDataFormatUtils.SEPARATOR);
            sb.append("unixtimestamp");
            sb.append(IESDataFormatUtils.SEPARATOR);

            List<LogRecordContainer> containers = group.getList();
            for (int i = 0; i < containers.size(); i++) {
                sb.append(containers.get(i).getChannelId());
                if (LoggerUtils.hasNext(containers, i)) {
                    sb.append(IESDataFormatUtils.SEPARATOR);
                }
            }
            headerCurrent = sb.toString();
            out.println(sb.toString());

            out.flush();
        }
    }

    /**
     * Returns the header before this generated one.
     *
     * @return the header before this generated one.
     */
    public String getOldHeader() {
        return headerOld;
    }

    /**
     * Construct a header row with predefined separators and comment signs.
     *
     * @param col_no          column number example: #001
     * @param col_name        column name example: YYYYMMDD
     * @param confidential    false or true
     * @param measured        false or true
     * @param unit            example: kWh
     * @param category        example: time
     * @param valueType       example: DOUBLE
     * @param valueTypeLength example: 8
     * @param comment         a comment
     * @return a string.
     */
    private String createRow(String col_no,
                             String col_name,
                             String confidential,
                             String measured,
                             String unit,
                             String category,
                             String valueType,
                             int valueTypeLength,
                             String comment) {

        String seperator = IESDataFormatUtils.SEPARATOR;
        String com_sign = IESDataFormatUtils.COMMENT;
        String vtEndSign = IESDataFormatUtils.VALUETYPE_ENDSIGN;
        String vtSizeSep = IESDataFormatUtils.VALUETYPE_SIZE_SEPARATOR;
        String valueTypeLengthString = "";
        if (valueTypeLength != 0) {
            valueTypeLengthString += valueTypeLength;
        }

        return (com_sign
                + col_no
                + seperator
                + col_name
                + seperator
                + confidential
                + seperator
                + measured
                + seperator
                + unit
                + seperator
                + category
                + seperator
                + valueType
                + vtSizeSep
                + valueTypeLengthString
                + vtEndSign
                + comment
                + "\n");
    }

    /**
     * Calculates the difference between the configured local time and the Coordinated Universal Time (UTC) without
     * daylight saving time and returns it as a string.
     *
     * @return the difference between local time and UTC as string.
     */
    private String getDiffLocalUTC() {

        String ret;
        long time = 0;

        Calendar calendar = new GregorianCalendar(Locale.getDefault());

        time = calendar.getTimeZone().getRawOffset();
        time /= 1000 * 60 * 60;

        if (time >= 0) {
            ret = ("+ " + time);
        } else {
            ret = ("- " + time);
        }

        return ret;
    }

}
